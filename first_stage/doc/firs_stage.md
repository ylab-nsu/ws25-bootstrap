<div style="text-align: justify;">

## Аппаратное обеспечение
Для реализации проекта builder-hex0-stage1 был выбран модуль LicheePi Module 4A с платой расширения LicheePi 4A. На модуле установлены: SoC TH1520, состоящий из четырех ядер Xuantie C910, видео- и нейро-сопроцессорf, 16 Гб LPDDR4 памяти, eMMC ROM, два чипа физического уровня Ethernet и схема управления питанием. Плата расширения добавляет: слот для SD карт, разъемы Ethernet, аудио и видео выходы, DIP-переключатель для выбора режима загрузки и разъем расширения GPIO.  
В рамках реализации проекта builder-hex0-stage1 было необходимо иметь возможность общения через UART и возможность менять прошивку SoC. UART был подключен к UART компьютера BananaPi. Доступ к BananaPi осуществлялся по SSH, работа с COM портом велась через minicom. На переключателе была выбрана загрузка с SD карты, на которую заливался загрузочный образ с помощью dd.
Для понимания работы проекта рассмотрим процесс загрузки SoC
## Алгоритм работы ZSBL
0. Регистр PC первого ядра C910 после включения равен 0xFF_FFD0_0000, и указывает на BROM, содержащий ZSBL. Начинается загрузка.
1. Считывается значение сигналов DIP-переключателя выбора источника загрузки. В ZSBL фиксируется один из источников: eMMC, SD карта, NAND FLASH, NOR FLASH.
2. Инициализируется контроллер выбраного источника: контроллер eMMC, SDIO или QSPI.
3. Инициализируется UART0 в режиме 115200 8N1.
4. Из источника загрузки копируется первые 1,5 Мб данных в область адресного пространства 0xFF_E000_0000 - 0xFF_E017_FFFF, соответствующую SRAM.
5. Выполняется jump на адрес 0xFF_E000_0000.
6. В дальнейшем то, что загружено по адресу 0xFF_E000_0000 назовем первичным загрузчиком или First Stage Bootloader. В случае загрузки Linux первичный загрузчик обычно это U-Boot SPL.

## Алгоритм работы First Stage Bootloader при загрузке Linux
1. При необходимости переконфигурируется UART.
2. При необходимости переконфигурируется контроллер загрузочного устройства.
3. Инициализируется контроллер DDR SDRAM.
4. Возможно определяется файловая система/таблица разделов/разметка на загрузочном устройстве.
5. В DDR загружается Second Stage Bootloader, например U-Boot.
6. Выполняется jump на адрес 0x0, начало DDR.

## Алгоритм работы First Stage Bootloader при загрузке hex0
1. При необходимости переконфигурируется UART.
2. При необходимости переконфигурируется контроллер загрузочного устройства.
3. Инициализируется контроллер DDR SDRAM.
4. Предоставляются три UEFI-совместимые функции: прием/передача данных по UART, чтение/запись загрузочного устройства.
4. С загрузочного устройства в DDR загружается builder-hex0-stage1.bin.
5. Выполняется jump на адрес 0x0, начало DDR.
6. builder-hex0-stage1 собирает builder-hex0-stage2.hex0 в исполняемый код.
7. Выполняется jump на начало builder-hex0-stage2.

## Алгоритм работы реализованного First Stage Bootloader
1. Предоставляется функция передачи данных в UART.
2. builder-hex0-stage1 собирает payload.hex0 в исполняемый код.
3. Выполняется jump на начало payload.

Под payload.hex0 имеется ввиду некоторая полезная нагрузка, написанная на hex0, например программа печатающая "Hello world", или builder-hex0-stage2. Создание загрузочного образа состоит в конкатенации builder-hex0-stage1 и payload.hex0.
Было принято решение, что в рамках школы размер образа будет ограничен 256 кб. Полноценно собрать и запустить ядро linux в таких условиях не получится, но зато builder-hex0-stage1 и payload.hex0 пападают в регион, загружаемый ZSBL, и для доступа к ним нет необходимости реализовывать функцияю чтения диска.
Также было принято решение ограничить доступную payload оперативную память оставшимся 1,25 Мб SRAM-ом, чтобы не было необходимости инициализировать контроллер DDR. 
Карта памяти для payload выглядит следующим образом:
<pre>
               |                     |
               |         ...         |
               |                     |
<u>0xFF_E000_0000 |                     |</u>  
               |                     |
               | builder-hex0-stage1 |
               <u>|                     |</u>
               |                     |
               |                     |
               |    payload.hex0     |
               |                     |
<u>0xFF_E004_0000 |                     |</u>  
               |                     |
               |                     |
               |         RAM         |
               |                     |
               <u>|                     |</u>
               |                     |
               |        stack        |
<u>0xFF_E018_0000 |                     |</u>  
               |                     |
               |         ...         |
               |                     |
<u>0xFF_E701_4000 |                     |</u>  
               |                     |
               |        UART0        |
               <u>|                     |</u>
               |                     |
               |         ...         |
               |                     |
</pre>

## UART0
ZSBL настраивает UART0 на работу в режиме 115200 8N1, поэтому ни в коде builder-hex0-stage1, ни в коде payload нет необходимости настраивать UART. Для передачи байта необходимо записать его в регистр TRH (смещение 0x0), принятые байты читаются из регистра RBR (смещение 0x0). 
Приемопередатчик UART имеет FIFO буфферы длиной 16 байт на прием и передачу. Текущее количество байт в каждом из FIFO может быть прочитано в регистрах RFL (смещение 0x80) и TFL (смещение 0x84) соответственно.  
При работе без использования прерываний для того, чтобы передавать данные без потерь необходимо писать в регистр TRH только про условии TFL < 16, чтобы принимать - читать регистр RBR, не допуская RFL >= 16. В режиме 11520 8N1 регистр RFL должен проверяться с периодом не более (8 + 2(старт и стоп биты)) $\cdot$ 16 / 115200 $\approx$ 1,4 мс. Псевдокод для обоих случаев представлен ниже:
```
fn uart_tx(string s):
    char c
    for c in s:
        while UART0.TFL >= 16:
            pass
        UART0.TRH := c

fn uart_rx_pool():
    string s
    while UART0.RFL >= 0:
        char c := UART0.RBR
        s.append(c)
    return s

fn main():
    ...
    uart_tx(tx_string)
    ...
    while true:
        ... # 1.4 ms
        string rx_string := uart_rx_pool() 

```

## SDIO
SoC TH1520 имеет два контроллера SDIO и один кнтроллер eMCC. SD карта на плате LecheePi 4A подключена к контроллеру SDIO0. Регистры контроллера SDIO0 расположены по базовому адресу 0xFF_E709_0000. Интерфейс SDIO состоит из линий передачи тактового сигнала, команд и данных. Перед началом работы с данными SD карты ее необходимо сконфигурировать. Конфигурация состоит из последовательность команд управляющего устройства и ответов SD карты. Алгоритм конфигурации представлен в документации на контроллер памяти TH1520 и реализован в ZSBL. 
Также в документации описан алгоритм чтения/записи SD карты. Была начата реализация его в коде на Си, но возникла проблема с обращением к регистрам SDIO0.

</div>