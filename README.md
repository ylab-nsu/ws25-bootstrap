<div style="text-align: justify;">

# ws25-bootstrap

## Мотивация

Современные версии операционных систем и программ для них зачастую написаны на C и C++. При этом компиляторы этих языков также написаны на языках C и C++, что приводит к циклической зависимости. Для сборки компилятора нужен компилятор, нужна последовательная сборка тулчейна от минимального компилятора к полноценному компилятору. 

Проблема Trusting Trust заключается в том, что мы должны доверять всей этой цепочке компиляторов. В статье "Reflections on Trusting Trust" Кена Томпсона представлен пример вредоносного кода с поведением вида: обычную программу собрать без изменений, компилятор собрать вставив самого себя, login собрать с возможностью root доступа для злоумышленника. 

Решением этой проблемы будет автоматическое развертывание доверенного окружения, начиная с простого компилятора, исходный код которого легко сравнить с получившимся исполняемым файлом. Проект [fosslinux/live-bootstrap](https://github.com/fosslinux/live-bootstrap) предназначен для сборки ядра Linux на процессорах архитектуры x86. Минимальное стартовое окружение называется builder-hex0, и написано на языке hex0. hex0 состоит из двух частей builder-hex0-stage1 и builder-hex0-stage2. builder-hex0-stage2 представляет собой минимальное ядро пригодное для компиляции дальнейших шагов. builder-hex0-stage1 - минимальный транслятор hex0 кода в исполняемый код.

## Цель

За основу взят проект [fosslinux/live-bootstrap](https://github.com/fosslinux/live-bootstrap), позволяющий произвести компиляцию ядра Linux из минимального набора бинарных файлов. Целью было развернуть builder-hex0-stage2 на архитектуре RISCV.

## Задачи

- [x] Портировать builder-hex0-stage1 на LecheePi 4A
  -  [x] Настроить процесс сборки загрузочных образов для LecheePi 4A
  -  [x] Реализовать передачу данных по UART 
  -  [x] Переписать builder-hex0-stage1 на ассемблер RISCV
- [x] Изучить builder-hex0-stage2
  - [x] Написать псевдокод builder-hex0-stage2
  - [x] Задокументировать основные особенности builder-hex0-stage2
  - [x] Выявить потенциальные точки улучшения системы

## Сборка проекта

### Makefile 
Пишет Волк

### Сборка stage-1 из исходного кода
Пишет Волк

1. Установите требуемые зависимости

    ```bash
    sudo apt install gcc-riscv64-unknown-elf
    ```

    Для запуска на qemu дополнительно установите `qemu-system-riscv64`:

    ```bash
    sudo apt install qemu-system-riscv64
    ```

2. Соберите объектный файл

    ```bash
    riscv64-unknown-elf-as ./src/stage1.s -o stage1.o
    ```

3. Сгенерируйте elf-файл

    ```bash
    riscv64-unknown-elf-ld -Ttext 0 stage1.o -o stage1.elf
    ```

4. Сгенерируйте бинарный файл

    ```bash
    riscv64-unknown-elf-objcopy -O binary stage1.elf stage1.bin
    ```

5. Запустите бинарный файл

    1. Для запуска на реальном устройстве скопируйте бинарный файл на диск (в примере `/dev/sda`)

        ```bash
        dd if=stage1.bin of=/dev/sda
        ```

    2. Для запуска на qemu:

        ```bash
        qemu-system-riscv64 //TBD
        ```

### Запуск stage-1 из hex0
Пишет Волк

1. Установите требуемые зависимости

    ```bash
    sudo apt install xxd
    ```

    Для запуска на qemu установите `qemu-system-riscv64`:

    ```bash
    sudo apt install qemu-system-riscv64
    ```

2. Получите из hex0 бинарный файл

    ```bash
    sed 's/[;#].*$//g' stage1.hex0 | xxd -r -p > stage1.bin
    ```

3. Запустите бинарный файл

    1. Для запуска на реальном устройстве скопируйте бинарный файл на диск (в примере `/dev/sda`)

        ```bash
        dd if=stage1.bin of=/dev/sda
        ```

    2. Для запуска на qemu:

        ```bash
        qemu-system-riscv64 //TBD

## Документация проекта

- [Документация на wiki](./wiki)
- [Псевдокод](./disassembly.c)